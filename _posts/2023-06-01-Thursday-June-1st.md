## Theorem Prover Summer School

## Two Week Summer School
- I have been attending a Summer School on Formal Methods for the past two weeks! It's truly been amazing.
- I have a confession; I haven't done any Computer Science things in a while, and I had a *lot* of anxiety once I found
out there would be a fair number of Computer Science PhD students there. As it turns out, I would say it was about 80 percent
CS people, and 20 percent Maths (Model Theory people, etc), with some people from industry (Nvidia, Sandia, etc) too. And it 
was exceptional.
- It was a very close-knit group, and even though we worked together, we also took a trip to San Francisco, did a hike at the 
Stanford Dish Trail and campus, did trips to various tech companies, the Computer History museum, and all the things (including
several boba runs). In fact, it's been so positive that a group of us will continue to learn one of the theorem provers together and continue to meet after the workshop ends, which is amazing!

## As for the workshop
- The format was as such: in the first week, we had lectures in the morning, and labs in the afternoon (two each), where we 
were exposed to various Theorem Provers such as the Vampire Theorem prover, Alloy, PVS, and TPTP. TPTP has wonderful syntax,
and Geoff's website adds a delay to a random user if you don't donate, which I thought was pretty funny. In one of my runs, I did get the delay, but I didn't really notice, tbh.
- We honestly also got enough knowledge to build our own theorem prover, too, which is awesome and something maybe I do in the future (with more time, after my PhD).
- We had a lovely talk by Carolyn Talcott on McCarthy's paper for its 60th birthday, and a session with Leslie Lamport on Paxos.
- We also did questions like a Soduku solver, and DDH using Easycrypt. Easycrypt looks interesting and definitely something I may put my hands on in the future, as it's very applicable to some of the work I'm doing.

## My purpose for attending
- I'm learning Lean in-depth this summer on my own, and am interested in using it as a tool for my work now and in the future.
Firstly, mathematicians tend to like it, and it seems to have symbols that are very similar to stuff I'm already using in my
other classes / papers I read. Finally, I don't have that much pressure by programming languages (PL) people to get sucked into the things they all talk about (types, category theory blah blah blah) in Lean. Those things exist, but there are mathematicians who just use them because they want to do things and be left alone, except if they are stuck and have questions to ask. And that sort of community is fine by me.
- It made me realize that I can completely learn and use these tools (I liked Isabelle as well, but sticking with Lean for now),
and I don't have to be interested in Programming Languages (not everyone wants to build languages! I wish some communities would stop selling formal verification as "PL" because there's a distinction that can be missed between the communities; I don't want to build a compiler in a functional programming language and feel superior about it even though no one uses it lol), but just use it as a tool for checking my assumptions about cryptography as I work through a system (modelling behavior, verifying my assumptions are correct). So that's kind of been my goal. Plus, a lot of Mathematicians seem to like it, so unlike some of the other tools, it's not a tool that would distance me from the community I want to be a part of as I continue to do research (i.e. Mathematics and post-quantum cryptography).
- PL is its own rabbit hole, and I don't know if it's just the culture but I don't want to feel inferior because I don't use some random unicode in Vim or Emacs or something from some random library for something I honestly don't need because I don't want to make a language or do some compiler thing; I just want to be able to prove thing on a piece of paper, and check it in a programme. So I really liked that this workshop had a breadth of tools, but then problems to solve using a theorem prover of your choice. 
- What was interesting is that people at the workshop thought I was more "Mathy" on the scale of people there, which was interesting. And they were asking me about how to get into more "Math things". So that was surprising, because in the past when I was hanging around PL people, they'd wave their knowledge of compiler stuff as being because *they* were more Mathy, but now that I've spent quite a bit of time just hanging out with Mathematicians, maybe I might know some more things now? In any case, maybe those initial PL people I met (not at the workshop) were just kind of insecure jerks? Who knows; I'm just super happy for this experience at this workshop, and for having so many friends who are Mathematicians, which has allowed me the opportunity to see beauty in what they dedicate so much of their time and energy into.
- Also, finally, good news: I got into another workshop on my topic of research, which will be in August! I'm super stoked about that! 

## Here are some photos from the summer school!

<img src="/images1/FormalMethods23/fm1.png" width="400">

- On the way to San Francisco via Caltrain!

<img src="/images1/FormalMethods23/fm2.png" width="400">

- On the Stanford Dish Trail!

<img src="/images1/FormalMethods23/fm3.png" width="400">

- At Fisherman's Wharf in SF!

<img src="/images1/FormalMethods23/fm4.png" width="400">

- Also in SF

<img src="/images1/FormalMethods23/fm5.png" width="400">

- Making our way back to Caltrain at the end of the night

<img src="/images1/FormalMethods23/fm6.png" width="400">

- At the dish at Stanford Dish trail.

<img src="/images1/FormalMethods23/fm7.png" width="400">

- Beautiful sunset at Stanford Dish trail.

<img src="/images1/FormalMethods23/fm8.png" width="400">

<img src="/images1/FormalMethods23/fm9.png" width="400">

<img src="/images1/FormalMethods23/fm10.png" width="400">

- Touring Stanford

<img src="/images1/FormalMethods23/fm11.png" width="400">

<img src="/images1/FormalMethods23/fm12.png" width="400">

- Union Square in SF photo

<img src="/images1/FormalMethods23/fm13.png" width="400">

<img src="/images1/FormalMethods23/fm14.png" width="400">

- Someone asked Lamport a GPT generated question during the Q&A session

<img src="/images1/FormalMethods23/fm15.png" width="400">

- Learning TPTP from Geoff

<img src="/images1/FormalMethods23/fm16.png" width="400">

- Wine made by scientists at SRI!

<img src="/images1/FormalMethods23/fm17.png" width="400">

- Carolyn talks about "A basis for a Mathematical Theory of Computation"

<img src="/images1/FormalMethods23/fm18.png" width="400">

<img src="/images1/FormalMethods23/fm19.png" width="400">

<img src="/images1/FormalMethods23/fm20.png" width="400">

- Andrei gives out certificates from the summer school with Shankar

<img src="/images1/FormalMethods23/fm21.png" width="400">

- Banquet desserts

<img src="/images1/FormalMethods23/fm22.png" width="400">

- Jesse gives a talk on Verifying LLMs and Challenges in that space that could benefit from a formal methods approach.

<img src="/images1/FormalMethods23/fm23.png" width="400">

- elote! I've been dreaming about elote since there isn't good elote where I live!

<img src="/images1/FormalMethods23/fm24.png" width="400">

<img src="/images1/FormalMethods23/fm25.png" width="400">

## In Conclusion
- I highly recommend it!
- There are a number of fields that could benefit from these methods, and in particular, what they emphasize is in particular fields that do not know they necessarily need them, rather than just the typical "programming languages" approach. In fact, I used to think
that PL was formal verification, but they're two quite separate fields, and I really enjoyed learning about them in a context that
wasn't just focused on programming languages techniques and approaches. 
- For Formal verification, you don't need to build a compiler; you can think of anything from verifying a process of logic for something like an autonomous car or a washing machine. Basically, anything where you might want to model the process of thinking and how things might go wrong and mitigate those risks. I think that's a much better sell than the muddied belief that you need to write a compiler for things or a programming language. So this opens up the possibilities to a lot of fields where you have general problems of uncertainty or critical systems. And that's kind of how they had us think about things, which I appreciated. As they said in a recent MSRI anniversary panel, "Mathematics is clarity of thinking". And bear in mind, PL is not "mathematics"; it is an applied discipline (at least in my mind for now) of compilers / theory of computation + from Model Theory, which is the discipline of Logic in Mathematics. There are many areas of Mathematics that are beautiful and people should take the time to be exposed to more of them, in the same way that people should not just assume that "Machine Learning is Mathy" means if you learned ML you'd be exposed to all the Maths.
- A final misconception I hear from people in PL is that "Machine Learning people can't do Mathematics". I think that that's a wrong assumption, in the same way that (forward-backward and backward-forward proof lol) we can't assume all PL people are experts in Mathematics (also wrong; if you're doing mostly implementation stuff, that may not necessarily be the case). It depends on one's discipline, and there is a range within people work depending on their specialization. For example, someone like Jesse works in ML and Formal Verification and has a PhD in Mathematics, so he actually has a stronger background than many PL people. But that is not necessarily the case for all PL people. I guess that even writing this out logically shows that some people who do applied logic for their work haven't thought deeply of all the cases. 
- I think it would be better to work together and to respect the boundaries of disciplines; all of this work takes effort and years of gaining expertise. Saying that because someone processes data that "that's easy" is silly. We all have things we are good at or are willing to spend lots of time on, and other things we don't enjoy, and we all need progress from all disciplines. I don't think it serves the PL community to be constantly bashing ML, or vice versa. If it turns out that they need systems of data verified, and programmes to do that, then we all benefit. But creating rifts between those communities and teaching the new crop of researchers superiority complexes doesn't help anyone. I find those kinds of things to be very toxic as someone who is an eary-career researcher. If someone recognizes the value a community might provide to a problem in another field, it helps everyone.
- Anyways, I learned so much, and it was very applicable to my area of
research! I would definitely like to return within a year, having stuck with Lean and with the working group (using PVS) to see how that would impact my experience.

## That's it
